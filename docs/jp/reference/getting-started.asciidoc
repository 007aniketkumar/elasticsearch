[[getting-started]]
= 始めてみよう

[partintro]
--

Elasticsearchは、オープソースの高スケーラブルな全文検索および分析エンジンです。大容量のデータをすばやく、ほぼリアルタイムで保存、検索、分析できます。通常、検索の機能と要件が複雑なアプリケーションを強化する基礎となるエンジン/技術として使用されます。

以下に、Elasticsearchの使用例をいくつか示します。

* 顧客が販売製品を検索できるオンラインWebストアを運営します。この事例では、Elasticsearchを使用して、全製品のカタログと在庫を保存し、顧客に検索とオートコンプリートの提案を提供できます。
* ログデータやトランザクションデータを収集し、このデータを分析および探索して、傾向、統計情報、要約、または例外を探します。この事例では、Logstash（Elasticsearch/Logstash/Kibana Stackに含まれる）を使用して、データを収集、集約、および解析して、LogstashがElasticsearchにこのデータを送るようにすることができます。データがElasticsearchに送られた後、検索と集約を実行して、関心のある情報を探索できます。
* 価格に敏感な顧客が「特定の電子ガジェットの購入に興味があり、この1か月以内にいずれかのベンダーのガジェット価格がXドルを下回ったときに通知を受け取りたい」といったルールを指定できる価格警報プラットフォームを運用します。この事例では、ベンダー価格を収集しElasticsearchにプッシュして、逆検索（パーコレータ）機能を使用して、価格変動と顧客のクエリを比較して一致が見つかったときに顧客に警報をプッシュできます。
* 分析/ビジネスインテリジェンスのニーズがあり、大量のデータ（無数のレコードを想定）について調査、分析、視覚化、および特別な質問をすばやく行います。この事例では、Elasticsearchを使用してデータを保存し、Kibana（Elasticsearch/Logstash/Kibana Stackに含まれる）を使用して、自分にとって重要なデータの側面を視覚化できるカスタムダッシュボードを作成できます。さらに、Elasticsearchの集約機能を使用して、データに対する複雑なビジネスインテリジェンスのクエリを実行できます。

以降のチュートリアルでは、Elasticsearchの起動、その内容の一部の確認、および基本的な操作（データのインデキシング、検索、修正など）のプロセスについて説明します。このチュートリアルの最後には、Elasticsearchとその機能についてよく理解し、Elasticsearchを使用して洗練された検索アプリケーションを作成したりデータの情報を探索したりする方法を知りたいという気になっているでしょう。
--

[[gs-basic-concepts]]
== 基本概念

Elasticsearchの中心となる概念がいくつかあります。最初にこれらの概念を理解すると、学習プロセスが容易になります。

[float]
=== ほぼリアルタイム（NRT）

Elasticsearchは、ほぼリアルタイムの検索プラットフォームです。つまり、ドキュメントにインデックスを付けてから検索可能になるまでにわずかな待ち時間（通常は1秒）があります。

[float]
=== クラスタ

クラスタは、データ全体を一緒に保持する1つ以上のノード（サーバー）のコレクションで、すべてのノードにわたって統合したインデキシング機能と検索機能を提供します。クラスタは、一意の名前で識別されます。デフォルトの名前は、「elasticsearch」です。名前でクラスタに参加するようにセットアップされている場合、ノードは1つのクラスタにしか含めることができないため、この名前は重要となります。

別の環境で同じクラス名を再利用しないでください。再利用すると、ノードを間違ったクラスタに参加させてしまう可能性があります。
たとえば、開発クラスタ、ステージングクラスタ、本番クラスタに`logging-dev`、`logging-stage`、`logging-prod`を使用します。

これは、クラスタにノードが1つしかない場合に有効かつ十分であることに注意してください。さらに、複数の独立したクラスタにそれぞれ独自のクラスタ名を付けることもできます。

[float]
=== ノード

ノードは、クラスタに含まれ、データを保存し、クラスタのインデキシング機能と検索機能に関係する1台のサーバーです。クラスタと同様に、ノードは名前で識別されます。デフォルトでは、起動時にノードに割り当てられるランダムなユニバーサル固有識別子（UUID）になります。デフォルトの名前にしたくない場合は、任意の名前を定義できます。この名前は、ネットワーク内のサーバーとElasticsearchクラスタ内のノードの対応を特定する必要がある管理目的に重要です。

クラスタ名で特定のクラスタに参加するように、ノードを設定できます。デフォルトで各ノードは、`elasticsearch`という名前のクラスタに参加するようにセットアップされます。つまり、ネットワーク上で複数のノードを起動すると（相互に検知可能であることを想定）、そのノードはすべて、`elasticsearch`という1つのクラスタを自動的に形成し参加します。

1つのクラスタには、必要な数のノードを含めることができます。さらに、現在ネットワーク上に別のElasticsearchノードが稼働していない場合、1つのノードを起動すると、`elasticsearch`という単一ノードのクラスタがデフォルトで形成されます。

[sect2]
[float]
=== インデックス

インデックスとは、同様の特性を持つドキュメントのコレクションです。たとえば、顧客データ、製品カタログ、注文データにそれぞれ別のインデックスを付けることができます。インデックスは名前（すべて小文字）で識別されます。この名前を使用して、ドキュメントに対してインデキシング、検索、更新、および削除の操作を実行する際にインデックスを参照します。

1つのクラスタには、必要な数のインデックスを定義できます。

[float]
=== タイプ

インデックス内に1つ以上のタイプを定義できます。タイプは、ユーザーがそのセマンティックスを自由に定義できる論理カテゴリ/区分です。一般に、タイプは一連の共通フィールドを持つドキュメントに定義されます。たとえば、ブログ作成プラットフォームを実行して、すべてのデータを1つのインデックスに格納するとします。このインデックスには、ユーザーデータのタイプ、ブログデータのタイプ、さらにコメントデータのタイプを定義できます。

[float]
=== ドキュメント

ドキュメントは、インデックスを付けられる情報の基本単位です。たとえば、1つの顧客のドキュメント、1つの製品のドキュメント、さらに1つの注文のドキュメントを持つことができます。この文書は、ユビキタスインターネットデータ交換形式である http://json.org/[JSON]（JavaScript Object Notation）で表されます。

index/type内に、必要な数のドキュメントを格納できます。ドキュメントはインデックス内に物理的に存在しますが、実際にインデックス内のタイプへのインデキシング/割り当てを行う必要があることに注意してください。

[[getting-started-shards-and-replicas]]
[float]
=== シャード&レプリカ

インデックスは、単一ノードのハードウェア制限を超える大量のデータを格納する場合があります。たとえば、1TBのディスク容量をとる大量のドキュメントの単一インデックスは、単一ノードのディスクには適せず、単一ノードからの検索リクエストに応えるだけの処理速度も不足する可能性があります。

この問題を解決するために、Elasticsearchは、シャードという複数の部分にインデックスを分割できます。インデックスの作成時に、シンプルに必要な数のシャードを定義できます。各シャードはそれ自体が、クラスタ内のノード上でホストされるフル機能の独立した「インデックス」です。

シャードは、主に次の2つの理由で重要です。

* コンテンツ量を均一に分割/拡大可能
* シャード全体にわたって（場合によっては複数のノード上に）演算処理を分散および並列化でき、パフォーマンス/スループットを向上


シャードを分散する技法およびそのドキュメントを検索リクエストに統合する技法は、Elasticsearchにより完全に管理され、透過的に処理されます。

常に障害が予期されるネットワーク/クラウド環境で、シャード/ノードが何らかの理由でオフラインになるか表示されなくなった場合のフェイルオーバーメカニズムがあると非常に便利であり、これを強くお勧めします。このために、Elasticsearchでは、1つ以上のインデックスのシャードをいわゆるレプリカシャード（略してレプリカ）にコピーできます。

レプリケーションは、主に次の2つの理由で重要です。

* シャード/ノードに障害が発生した場合の高可用性が提供されます。この理由で、レプリカシャードをコピー元のオリジナル/プライマリと同じノードに割り当てないように注意することが大切です。
* 検索はすべてのレプリカで並列に実行できるため、検索の量/スループットを拡張できます。


要約するために、各インデックスは複数のシャードに分割されます。インデックスも、ゼロ個（つまりレプリカなし）または1個以上のレプリカを作成できます。レプリカが作成されると、各インデックスはプライマリシャード（レプリカを作成したオリジナルのシャード）とレプリカシャード（プライマリシャードのコピー）を持ちます。
シャードとレプリカの数は、インデックスの作成時にインデックスごとに定義されます。インデックスが作成された後、レプリカの数はいつでも動的に変更できますが、シャードの数は後になってからは変更できません。

デフォルトでは、Elasticsearchの各インデックスは5つのプライマリシャードと1つのレプリカを割り当てられます。これは、クラスタに少なくとも2つのノードがある場合、インデックスは、インデックスにつき合計10個のシャードのうち、5つのプライマリシャードと5つのレプリカシャード（完全なレプリカ1つ）を持つということです。

NOTE: 各ElasticsearchシャードはLuceneインデックスです。1つのLuceneインデックスのドキュメント数には上限があります。 https://issues.apache.org/jira/browse/LUCENE-5843[`LUCENE-5843`]では、上限は`2,147,483,519`（= Integer.MAX_VALUE - 128）ドキュメントです。
{ref}/cat-shards.html[`_cat/shards`]APIを使用してシャードのサイズを監視できます。

その他については、興味のあるところから始めてください。

[[gs-installation]]
== インストール

Elasticsearchには、Java 8以降が必要です。特にこの文書の執筆時において、Oracle JDKバージョン{jdk}の使用を推奨します。Javaのインストールはプラットフォームごとに異なりますが、ここでは詳細について説明しません。Oracleが推奨するインストールマニュアルは、 http://docs.oracle.com/javase/8/docs/technotes/guides/install/install_overview.html[Oracle's website]にあります。ここでは、Elasticsearchをインストールする前に、最初に次のコマンドを実行して、お使いのJavaのバージョンをチェックしてください（必要に応じて、インストール/アップグレードしてください）。

[source,sh]
--------------------------------------------------
java -version
echo $JAVA_HOME
--------------------------------------------------

Javaのセットアップを完了したら、Elasticsearchをダウンロードして実行できます。バイナリは、過去に作成されたすべてのリリースとともに、 http://www.elastic.co/downloads[`www.elastic.co/downloads`]から入手できます。リリースごとに、`zip`アーカイブや`tar`アーカイブ、または`DEB`パッケージや`RPM`パッケージから選択できます。簡単にするために、ここではtarファイルを使用します。

次のように、Elasticsearch {version} のtarをダウンロードします（Windowsユーザーはzipパッケージをダウンロードします）。

["source","sh",subs="attributes,callouts"]
--------------------------------------------------
curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-{version}.tar.gz
--------------------------------------------------
// NOTCONSOLE

次のように、展開します（Windowsユーザーはzipパッケージを解凍します）。

["source","sh",subs="attributes,callouts"]
--------------------------------------------------
tar -xvf elasticsearch-{version}.tar.gz
--------------------------------------------------

現在のディレクトリに多数のファイルとフォルダが作成されます。次のように、binディレクトリに移動します。

["source","sh",subs="attributes,callouts"]
--------------------------------------------------
cd elasticsearch-{version}/bin
--------------------------------------------------

これで次のように、ノードと単一のクラスタを起動する準備ができました（Windowsユーザーはelasticsearch.batファイルを実行します）。

[source,sh]
--------------------------------------------------
./elasticsearch
--------------------------------------------------

すべてが正常に実行されると、以下のような多くのメッセージが表示されます。

["source","sh",subs="attributes,callouts"]
--------------------------------------------------
[2016-09-16T14:17:51,251][INFO ][o.e.n.Node               ] [] initializing ...
[2016-09-16T14:17:51,329][INFO ][o.e.e.NodeEnvironment    ] [6-bjhwl] using [1] data paths, mounts [[/ (/dev/sda1)]], net usable_space [317.7gb], net total_space [453.6gb], spins? [no], types [ext4]
[2016-09-16T14:17:51,330][INFO ][o.e.e.NodeEnvironment    ] [6-bjhwl] heap size [1.9gb], compressed ordinary object pointers [true]
[2016-09-16T14:17:51,333][INFO ][o.e.n.Node               ] [6-bjhwl] node name [6-bjhwl] derived from node ID; set [node.name] to override
[2016-09-16T14:17:51,334][INFO ][o.e.n.Node               ] [6-bjhwl] version[{version}], pid[21261], build[f5daa16/2016-09-16T09:12:24.346Z], OS[Linux/4.4.0-36-generic/amd64], JVM[Oracle Corporation/Java HotSpot(TM) 64-Bit Server VM/1.8.0_60/25.60-b23]
[2016-09-16T14:17:51,967][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [aggs-matrix-stats]
[2016-09-16T14:17:51,967][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [ingest-common]
[2016-09-16T14:17:51,967][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [lang-expression]
[2016-09-16T14:17:51,967][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [lang-groovy]
[2016-09-16T14:17:51,967][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [lang-mustache]
[2016-09-16T14:17:51,967][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [lang-painless]
[2016-09-16T14:17:51,967][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [percolator]
[2016-09-16T14:17:51,968][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [reindex]
[2016-09-16T14:17:51,968][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [transport-netty3]
[2016-09-16T14:17:51,968][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded module [transport-netty4]
[2016-09-16T14:17:51,968][INFO ][o.e.p.PluginsService     ] [6-bjhwl] loaded plugin [mapper-murmur3]
[2016-09-16T14:17:53,521][INFO ][o.e.n.Node               ] [6-bjhwl] initialized
[2016-09-16T14:17:53,521][INFO ][o.e.n.Node               ] [6-bjhwl] starting ...
[2016-09-16T14:17:53,671][INFO ][o.e.t.TransportService   ] [6-bjhwl] publish_address {192.168.8.112:9300}, bound_addresses {{192.168.8.112:9300}
[2016-09-16T14:17:53,676][WARN ][o.e.b.BootstrapCheck     ] [6-bjhwl] max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]
[2016-09-16T14:17:56,718][INFO ][o.e.c.s.ClusterService   ] [6-bjhwl] new_master {6-bjhwl}{6-bjhwl4TkajjoD2oEipnQ}{8m3SNKoFR6yQl1I0JUfPig}{192.168.8.112}{192.168.8.112:9300}, reason: zen-disco-elected-as-master ([0] nodes joined)
[2016-09-16T14:17:56,731][INFO ][o.e.h.HttpServer         ] [6-bjhwl] publish_address {192.168.8.112:9200}, bound_addresses {[::1]:9200}, {192.168.8.112:9200}
[2016-09-16T14:17:56,732][INFO ][o.e.g.GatewayService     ] [6-bjhwl] recovered [0] indices into cluster_state
[2016-09-16T14:17:56,748][INFO ][o.e.n.Node               ] [6-bjhwl] started
--------------------------------------------------

あまり詳細には立ち入らずに、「6-bjhwl」（ケース次第で文字のセットが異なる）という名前のノードが起動し、単一クラスタのマスタとして選択されていることを確認できます。今のところ、マスタの意味を気にする必要はありません。ここで重要なことは、1つのクラスタ内で1つのノードを起動したということです。

前に述べたように、クラスタまたはノードの名前を上書きできます。これは、次のようにElasticsearchの起動時にコマンドラインから実行できます。

[source,sh]
--------------------------------------------------
./elasticsearch -Ecluster.name=my_cluster_name -Enode.name=my_node_name
--------------------------------------------------

ノードに到達できるHTTPアドレス（`192.168.8.112`）とポート（`9200`）に関する情報を持つhttpとマークされたラインにも注目してください。デフォルトでElasticsearchはポート`9200`を使用して、そのREST APIを提供します。このポートは、必要に応じて設定できます。

[[gs-exploring-cluster]]
== クラスタの調査

[float]
=== REST API

これで、ノード（およびクラスタ）を稼働しました。次のステップでは、そのノードと通信する方法を理解します。幸いなことに、Elasticsearchは、クラスタとのやり取りに使用できる包括的で強力なREST APIを提供しています。このAPIには次のような機能があります。

* クラスタ、ノード、およびインデックスのヘルス、ステータス、および統計情報のチェック
* クラスタ、ノード、およびインデックスのデータとメタデータの管理
* CRUD（Create、Read、Update、Delete）およびインデックスに対する検索操作の実行
* ページング、ソート、フィルタリング、スクリプティング、集約など高度な検索機能の実行

[[cluster-health]]
=== クラスタヘルス

まず、基本的なヘルスチェックについて説明します。これを使用して、クラスタがどのように動作しているかを確認できます。これを行うためにcurlを使用しますが、HTTP/RESTの呼び出しが可能なツールも使用できます。では、Elasticsearchを起動したノード上で、別のコマンドシェルを開いているものとします。

クラスタヘルスをチェックするために、{ref}/cat[`_cat` API]を使用します。「VIEW IN CONSOLE」をクリックして{kibana}/console-kibana.html[Kibanaのコンソール]で以下のコマンドを実行します。または、以下の「COPY AS CURL」リンクをクリックしてターミナルに貼り付け、`curl`を使用して以下のコマンドを実行します。

[source,js]
--------------------------------------------------
GET /_cat/health?v
--------------------------------------------------
// CONSOLE

次のような応答が返ります。

[source,txt]
--------------------------------------------------
epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent
1475247709 17:01:49  elasticsearch green           1         1      0   0    0    0        0             0                  -                100.0%
--------------------------------------------------
// TESTRESPONSE[s/1475247709 17:01:49  elasticsearch/\\d+ \\d+:\\d+:\\d+ docs_integTestCluster/]
// TESTRESPONSE[s/0             0                  -/0             \\d+                  -/]
// TESTRESPONSE[_cat]

「elasticsearch」という名前のクラスタはgreenステータスで稼働しているのがわかります。

クラスタヘルスを求めると、green、yellow、またはredのいずれかになります。greenはすべてが正常である（クラスタは完全に機能する）ことを示し、yellowはすべてのデータを利用できるが一部のレプリカがまだ割り当てられていない（クラスタは完全に機能する）ことを示し、redは何らかの理由で一部のデータが利用できないことを示します。クラスタはredステータスでも部分的に機能します（つまり、利用可能なシャードからの検索リクエストに対応し続ける）。ただし、失われたデータがあるため、可能な限り速やかに修正する必要があります。

また、上記の応答から、ノードの合計が1であることと、まだデータがないためシャードが0であることがわかります。デフォルトのクラスタ名（elasticsearch）を使用しており、Elasticsearchはデフォルトでユニキャストネットワーク検出を使用して同じマシン上にある別のノードを検索するため、自分のコンピュータ上に複数のノードを間違って起動し、それらをすべて単一クラスタに参加させてしまう可能性があります。このシナリオでは、上記の応答に複数のノードが表示される場合もあります。

次のように、クラスタ内にあるノードのリストを取得できます。

[source,js]
--------------------------------------------------
GET /_cat/nodes?v
--------------------------------------------------
// CONSOLE

次のような応答が返ります。

[source,txt]
--------------------------------------------------
ip        heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name
127.0.0.1           10           5   5    4.46                        mdi      *      PB2SGZY
--------------------------------------------------
// TESTRESPONSE[s/10           5   5    4.46/\\d+ \\d+ \\d+ (\\d+\\.\\d+)? (\\d+\\.\\d+)? (\\d+\.\\d+)?/]
// TESTRESPONSE[s/[*]/[*]/ s/PB2SGZY/.+/ _cat]

ここでは、「PB2SGZY」という名前のノードが1つ表示されます。これは、現在クラスタ内にある単一ノードです。

[[list-all-indices]]
=== 全インデックスのリスト

インデックスを見てみましょう。

[source,js]
--------------------------------------------------
GET /_cat/indices?v
--------------------------------------------------
// CONSOLE

次のような応答が返ります。

[source,txt]
--------------------------------------------------
health status index uuid pri rep docs.count docs.deleted store.size pri.store.size
--------------------------------------------------
// TESTRESPONSE[_cat]

これは単に、クラスタ内にインデックスが存在していないという意味です。

[[gs-create-index]]
=== インデックスの作成

「customer」という名前のインデックスを作成して、再びすべてのインデックスをリストしてみましょう。

[source,js]
--------------------------------------------------
PUT /customer?pretty
GET /_cat/indices?v
--------------------------------------------------
// CONSOLE

最初のコマンドは、PUT動詞を使用して、「customer」という名前のインデックスを作成します。呼び出しの末尾に`pretty`を追加して、JSON応答をpretty-printするようにしています（ある場合）。

次のような応答が返ります。

[source,txt]
--------------------------------------------------
health status index    uuid                   pri rep docs.count docs.deleted store.size pri.store.size
yellow open   customer 95SQ4TSUT7mWBT7VNHH67A   5   1          0            0       260b           260b
--------------------------------------------------
// TESTRESPONSE[s/95SQ4TSUT7mWBT7VNHH67A/.+/ s/260b/\\d+b/ _cat]

2つ目のコマンドの結果は、customerという名前のインデックスが1つ、そのインデックスには5つのプライマリシャードと1つのレプリカ（デフォルト）があり、ゼロ個のドキュメントを含んでいることを示しています。

customerインデックスにyellowステータスがタグ付けされていることにも気づくと思います。yellowは一部のレプリカが割り当てられていないことを示しているという前の説明を思い出してください。このインデックスでこのステータスが生じたのは、Elasticsearchがデフォルトでこのインデックスのレプリカを1つ作成したためです。今のところ1つのノードしか稼働していないため、別のノードがクラスタに参加するまで、その1つのレプリカは（高可用性用に）割り当てられません。そのレプリカが2番目のノードに割り当てられると、このインデックスのヘルスステータスはgreenに変わります。

[[gs-index-query]]
=== ドキュメントのインデックスとクエリ

customerインデックスにインデキシングしてみましょう。ドキュメントにインデックスを付けるためには、インデックス内のどのタイプにするかをElasticsearchに指定する必要があったことを思い出してください。

次のように、「external」タイプでIDが1のcustomerインデックスにシンプルなcustomerドキュメントをインデキシングします。

[source,js]
--------------------------------------------------
PUT /customer/external/1?pretty
{
  "name": "John Doe"
}
--------------------------------------------------
// CONSOLE

次のような応答が返ります。

[source,sh]
--------------------------------------------------
{
  "_index" : "customer",
  "_type" : "external",
  "_id" : "1",
  "_version" : 1,
  "result" : "created",
  "_shards" : {
    "total" : 2,
    "successful" : 1,
    "failed" : 0
  },
  "created" : true
}
--------------------------------------------------
// TESTRESPONSE

上記の応答から、新しいcustomerドキュメントがcustomerインデックスとexternalタイプ内に正常に作成されたことがわかります。さらに、ドキュメントの内部IDが、インデキシングの際に指定した1になっています。

Elasticsearchでは、ドキュメントをインデキシングする前に、インデックスを明示的に作成する必要はありません。前の例では、customerインデックスがあらかじめ存在していない場合、Elasticsearchがcustomerインデックスを自動的に作成します。

次のように、インデキシングをしたドキュメントを取得します。

[source,js]
--------------------------------------------------
GET /customer/external/1?pretty
--------------------------------------------------
// CONSOLE
// TEST[continued]

次のような応答が返ります。

[source,js]
--------------------------------------------------
{
  "_index" : "customer",
  "_type" : "external",
  "_id" : "1",
  "_version" : 1,
  "found" : true,
  "_source" : { "name": "John Doe" }
}
--------------------------------------------------
// TESTRESPONSE

要求されたIDが1のドキュメントが見つかったことを示すフィールド`found`と、直前のステップでインデキシングした完全なJSONドキュメントを返すもう1つのフィールド`_source`以外に特に変わりありません。

[[gs-delete-index]]
=== インデックスの削除

作成したインデックスを削除して、再びすべてのインデックスをリストしてみましょう。

[source,js]
--------------------------------------------------
DELETE /customer?pretty
GET /_cat/indices?v
--------------------------------------------------
// CONSOLE
// TEST[continued]

次のような応答が返ります。

[source,txt]
--------------------------------------------------
health status index uuid pri rep docs.count docs.deleted store.size pri.store.size
--------------------------------------------------
// TESTRESPONSE[_cat]

これは、インデックスが正常に削除されたことを示しています。これで、クラスタに何もない最初の状態に戻りました。

先に進む前に、これまでに学習してきたAPIコマンドのいくつかをもう一度詳しく見てみましょう。

[source,js]
--------------------------------------------------
PUT /customer
PUT /customer/external/1
{
  "name": "John Doe"
}
GET /customer/external/1
DELETE /customer
--------------------------------------------------
// CONSOLE

上記のコマンドを注意して調べると、Elasticsearchでデータにアクセスする方法のパターンが実際にわかります。このパターンは次のようにまとめることができます。

[source,js]
--------------------------------------------------
<REST Verb> /<Index>/<Type>/<ID>
--------------------------------------------------
// NOTCONSOLE

このRESTアクセスパターンは、すべてのAPIコマンドに見られるので、これを覚えれば、Elasticsearchの習得に向けた良いスタートになります。

[[gs-modifying-data]]
== データの変更

Elasticsearchは、ほぼリアルタイムでのデータの操作機能と検索機能を提供します。デフォルトでは、データのインデキシング/更新/削除時から検索結果に表示されるまで1秒の遅延（更新間隔）があります。これは、トランザクションが完了するとすぐにデータが利用可能になるSQLのような他のプラットフォームとの大きな違いです。

[float]
=== ドキュメントのインデキシング/置き換え

前に、1つのドキュメントにインデックスを付ける方法について説明しました。もう一度、そのコマンドを思い出してみましょう。

[source,js]
--------------------------------------------------
PUT /customer/external/1?pretty
{
  "name": "John Doe"
}
--------------------------------------------------
// CONSOLE

上記のコマンドは、"external"タイプでIDが1のcustomerインデックスに指定したドキュメントをインデキシングします。異なる（または同じ）ドキュメントで上記のコマンドを再び実行すると、Elasticsearchは、IDが1の既存のドキュメントの上に新しいドキュメントを置換（または再インデキシング）します。

[source,js]
--------------------------------------------------
PUT /customer/external/1?pretty
{
  "name": "Jane Doe"
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記のコマンドは、IDが1のドキュメントの名前を「John Doe」から「Jane Doe」に変更します。それに対して、異なるIDを使用すると、新しいドキュメントにインデックスが付けられ、インデックス内の既存のドキュメントはそのまま残ります。

[source,js]
--------------------------------------------------
PUT /customer/external/2?pretty
{
  "name": "Jane Doe"
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記のコマンドは、IDが2の新しいドキュメントにインデックスを付けます。

インデキシングの際、ID部分はオプションです。指定しない場合、ElasticsearchはランダムIDを生成し、そのIDを使用してドキュメントにインデックスを付けます。Elasticsearchが生成する実際のID（または前の例で明示的に指定したID）は、インデックスAPI呼び出しの一部として返されます。

次の例は、IDを明示せずにドキュメントにインデックスを付ける方法を示しています。

[source,js]
--------------------------------------------------
POST /customer/external?pretty
{
  "name": "Jane Doe"
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記の事例では、IDを指定しないので、PUTではなく`POST`動詞を使用していることに注意してください。

[[gs-update-docs]]
=== ドキュメントの更新

ドキュメントのインデキシングと置き換えが可能であるだけでなく、ドキュメントを更新することもできます。ただし実際は、特定の状況下において、Elasticsearchは所定の更新を行わないことに注意してください。更新を行うと、Elasticsearchは古いドキュメントを削除してから、更新が適用された新しいドキュメントにインデックスを一括で付けます。

次の例は、nameフィールドを「Jane Doe」に変更して、前のドキュメント（IDが1）を更新する方法を示しています。

[source,js]
--------------------------------------------------
POST /customer/external/1/_update?pretty
{
  "doc": { "name": "Jane Doe" }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

次の例は、nameフィールドを「Jane Doe」に変更して、前のドキュメント（IDが1）を更新し、同時にageフィールドを追加する方法を示しています。

[source,js]
--------------------------------------------------
POST /customer/external/1/_update?pretty
{
  "doc": { "name": "Jane Doe", "age": 20 }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

シンプルなスクリプトを使用して、更新を実行することもできます。次の例は、スクリプトを使用して、年齢を5歳増やしています。

[source,js]
--------------------------------------------------
POST /customer/external/1/_update?pretty
{
  "script" : "ctx._source.age += 5"
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記の例では、`ctx._source`は更新される現在のソースドキュメントを指しています。

この文書の執筆時において、更新は一度に1つのドキュメントのみに実行できます。将来、Elasticsearchは、クエリ条件（`SQL UPDATE-WHERE`文など）を指定された複数のドキュメントを更新できるようになるかもしれません。

[[gs-delete-docs]]
=== ドキュメントの削除

ドキュメントの削除はとても簡単です。次の例は、IDが2の前のcustomerを削除する方法を示しています。

[source,js]
--------------------------------------------------
DELETE /customer/external/2?pretty
--------------------------------------------------
// CONSOLE
// TEST[continued]

特定のクエリに一致するドキュメントをすべて削除するには、{ref}/docs-delete-by-query.html[`_delete_by_query` API]を参照してください。
Delete By Query APIを使用してすべてのドキュメントを削除するよりも、インデックス全体を削除する方がはるかに効率的であることに注意してください。

[[gs-batch]]
=== バッチ処理

個別ドキュメントのインデキシング、更新、および削除が可能であるだけでなく、Elasticsearchは{ref}/docs-bulk.html[`_bulk` API]を使用してこれらのオペレーションのいずれかを一括で実行することもできます。この機能は、必要最小限のネットワークの往復で、複数の操作を可能な限り高速に実行する非常に効率の良いメカニズムを提供するという点で重要です。

簡単な例として、次の呼び出しは、一括操作で2つのドキュメントにインデックスを付けます（ID 1 - John DoeおよびID 2 - Jane Doe）。

[source,js]
--------------------------------------------------
POST /customer/external/_bulk?pretty
{"index":{"_id":"1"}}
{"name": "John Doe" }
{"index":{"_id":"2"}}
{"name": "Jane Doe" }
--------------------------------------------------
// CONSOLE

次の例は、一括操作で、1つ目のドキュメント（IDが1）を更新してから、2つ目のドキュメント（IDが2）を削除します。

[source,sh]
--------------------------------------------------
POST /customer/external/_bulk?pretty
{"update":{"_id":"1"}}
{"doc": { "name": "John Doe becomes Jane Doe" } }
{"delete":{"_id":"2"}}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記の削除操作の場合、削除には削除対象のドキュメントのIDのみが必要なため、削除操作後は対応するソースドキュメントがなくなります。

Bulk APIは、操作の1つに障害が生じても失敗しません。何らかの理由により単一の操作が失敗した場合、残りの操作は処理を続けます。Bulk APIが返ると、操作ごとのステータスが提供されるため（送信時と同じ順序）、特定の操作が失敗したかどうかをチェックできます。

[[exploring-data]]
== データの調査

[float]
=== サンプルデータセット

基本についてざっと説明しました。より現実的なデータセットを扱ってみましょう。顧客の銀行口座情報に関する架空のJSONドキュメント例を用意しました。各ドキュメントには、次のスキーマがあります。

[source,js]
--------------------------------------------------
{
    "account_number": 0,
    "balance": 16623,
    "firstname": "Bradshaw",
    "lastname": "Mckenzie",
    "age": 29,
    "gender": "F",
    "address": "244 Columbus Place",
    "employer": "Euron",
    "email": "bradshawmckenzie@euron.com",
    "city": "Hobucken",
    "state": "CO"
}
--------------------------------------------------
// NOTCONSOLE

このデータは http://www.json-generator.com/[`www.json-generator.com/`]で生成しました。データはすべてランダムに生成されていますので、実際の値とセマンティックは無視してください。

[float]
=== サンプルデータセットの読み込み
サンプルデータセット（accounts.json）は https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json?raw=true[ここ]からダウンロードできます。ダウンロードしたファイルを現在のディレクトリに展開して、次のようにクラスタに読み込みます。

[source,sh]
--------------------------------------------------
curl -H "Content-Type: application/json" -XPOST 'localhost:9200/bank/account/_bulk?pretty&refresh' --data-binary "@accounts.json"
curl 'localhost:9200/_cat/indices?v'
--------------------------------------------------
// NOTCONSOLE

////
This replicates the above in a document-testing friendly way but isn't visible
in the docs:

[source,js]
--------------------------------------------------
GET /_cat/indices?v
--------------------------------------------------
// CONSOLE
// TEST[setup:bank]
////

次のような応答が返ります。

[source,js]
--------------------------------------------------
health status index uuid                   pri rep docs.count docs.deleted store.size pri.store.size
yellow open   bank  l7sSYV2cQXmu6_4rJWVIww   5   1       1000            0    128.6kb        128.6kb
--------------------------------------------------
// TESTRESPONSE[s/128.6kb/\\d+(\\.\\d+)?[mk]?b/]
// TESTRESPONSE[s/l7sSYV2cQXmu6_4rJWVIww/.+/ _cat]

これは、1000個のドキュメントをbankインデックス（accountタイプの下）に正常に一括インデキシングしたことを示しています。

[[gs-search-api]]
=== Search API

シンプルな検索をいくつか始めてみましょう。検索を実行する基本的な方法は2つあります。 一つは{ref}/search-uri-request.html[RESTリクエストURI]を使用して検索パラメータを送信する方法で、もう一つは{ref}/search-request-body.html[RESTリクエストボディ]を使用して検索パラメータを送信する方法です。リクエストボディ方式では、表現がより豊かになり、読みやすいJSON形式で検索を定義することもできます。リクエストURI方式の一例を試しますが、このチュートリアルではこれよりリクエストボディ方式のみを使用します。

検索用のREST APIは、`_search`エンドポイントからアクセスできます。次の例は、bankインデックスにすべてのドキュメントを返します。

[source,js]
--------------------------------------------------
GET /bank/_search?q=*&sort=account_number:asc&pretty
--------------------------------------------------
// CONSOLE
// TEST[continued]

最初に、search呼び出しを分析します。検索（`_search`エンドポイント）はbankインデックス内で実行しており、`q=*`パラメータは、インデックス内のすべてのドキュメントに一致するようElasticsearchに指示します。`sort=account_number:asc`パラメータは、各ドキュメントの`account_number`フィールドを使用して結果を昇順でソートすることを示します。`pretty`パラメータは、pretty-printされたJSON結果を返すようElasticsearchに指示しています。

次のような応答が返ります（部分的に表示）。

[source,js]
--------------------------------------------------
{
  "took" : 63,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "failed" : 0
  },
  "hits" : {
    "total" : 1000,
    "max_score" : null,
    "hits" : [ {
      "_index" : "bank",
      "_type" : "account",
      "_id" : "0",
      "sort": [0],
      "_score" : null,
      "_source" : {"account_number":0,"balance":16623,"firstname":"Bradshaw","lastname":"Mckenzie","age":29,"gender":"F","address":"244 Columbus Place","employer":"Euron","email":"bradshawmckenzie@euron.com","city":"Hobucken","state":"CO"}
    }, {
      "_index" : "bank",
      "_type" : "account",
      "_id" : "1",
      "sort": [1],
      "_score" : null,
      "_source" : {"account_number":1,"balance":39225,"firstname":"Amber","lastname":"Duke","age":32,"gender":"M","address":"880 Holmes Lane","employer":"Pyrami","email":"amberduke@pyrami.com","city":"Brogan","state":"IL"}
    }, ...
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took" : 63/"took" : $body.took/]
// TESTRESPONSE[s/\.\.\./$body.hits.hits.2, $body.hits.hits.3, $body.hits.hits.4, $body.hits.hits.5, $body.hits.hits.6, $body.hits.hits.7, $body.hits.hits.8, $body.hits.hits.9/]

応答については、次の部分がわかります。

* `took` - Elasticsearchが検索の実行にかかった時間（ミリ秒）
* `timed_out` - 検索がタイムアウトしたかどうかを示す
* `_shards` - 検索されたシャードの数と検索に成功/失敗したシャードの数を示す
* `hits` - 検索結果
* `hits.total` - 検索基準に一致したドキュメントの数
* `hits.hits` - 検索結果の実際の配列（デフォルトで最初の10個のドキュメント）
* `hits.sort` - 結果のソートキー（スコアでソートする場合は欠落）
* `hits._score`と`max_score` - 今のところこれらのフィールドは無視

次に、代替のリクエストボディ方式を使用する、上記と同じ検索を示します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match_all": {} },
  "sort": [
    { "account_number": "asc" }
  ]
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

違いは、URIで`q=*`を渡すのではなく、JSON形式のクエリリクエストボディを`_search` APIにPOSTする点です。このJSONクエリについては、次のセクションで説明します。

////
Hidden response just so we can assert that it is indeed the same but don't have
to clutter the docs with it:

[source,js]
--------------------------------------------------
{
  "took" : 63,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "failed" : 0
  },
  "hits" : {
    "total" : 1000,
    "max_score": null,
    "hits" : [ {
      "_index" : "bank",
      "_type" : "account",
      "_id" : "0",
      "sort": [0],
      "_score": null,
      "_source" : {"account_number":0,"balance":16623,"firstname":"Bradshaw","lastname":"Mckenzie","age":29,"gender":"F","address":"244 Columbus Place","employer":"Euron","email":"bradshawmckenzie@euron.com","city":"Hobucken","state":"CO"}
    }, {
      "_index" : "bank",
      "_type" : "account",
      "_id" : "1",
      "sort": [1],
      "_score": null,
      "_source" : {"account_number":1,"balance":39225,"firstname":"Amber","lastname":"Duke","age":32,"gender":"M","address":"880 Holmes Lane","employer":"Pyrami","email":"amberduke@pyrami.com","city":"Brogan","state":"IL"}
    }, ...
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took" : 63/"took" : $body.took/]
// TESTRESPONSE[s/\.\.\./$body.hits.hits.2, $body.hits.hits.3, $body.hits.hits.4, $body.hits.hits.5, $body.hits.hits.6, $body.hits.hits.7, $body.hits.hits.8, $body.hits.hits.9/]

////

検索結果を返すと、Elasticsearchはリクエストを完了して、サーバー側のリソースを保守したり結果にカーソルを開いたりしないことを理解しておいてください。これは、あらかじめクエリ結果の部分的なサブセットを得ることができ、ステートフルサーバー側カーソルなどを使用して残りの結果をフェッチ（またはページング）したい場合は、続けてサーバーに戻す必要があるという点で、他の多くのプラットフォーム（SQLなど）とはまったく対照的です。

[[gs-query-lang]]
=== クエリ言語の紹介

Elasticsearchは、クエリの実行に使用できるJSON形式のドメイン固有言語を提供します。これは{ref}/query-dsl.html[Query DSL]とも呼ばれます。クエリ言語は非常に広範囲にわたるため、最初はとっつきにくいかもしれませんが、いくつかの基本的な例から学習を実際に始めてみると良いでしょう。

直前の例に戻って、次のクエリを実行しました。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match_all": {} }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記を分析すると、`query`部分はクエリの定義を示しており、`match_all`部分は単純に実行するクエリのタイプです。`match_all`クエリは、指定したインデックス内のドキュメントをすべて検索するだけです。

`query`パラメータのほかに、検索結果に影響する別のパラメータも渡すことができます。上記のセクションの例では`sort`を渡しました。次の例では`size`を渡します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match_all": {} },
  "size": 1
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

`size`が指定されない場合、デフォルトで10になります。

次の例では、`match_all`を実行し、ドキュメント11～20が返されます。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match_all": {} },
  "from": 10,
  "size": 10
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

`from`パラメータ（0で始まる）は開始するドキュメントインデックスを指定し、`size`パラメータは返すドキュメント数（fromパラメータで始まる）を指定します。この機能は、検索結果のページングを実装する際に使用します。`from`が指定されない場合、デフォルトで0になります。

次の例では、`match_all`を実行し、結果を預金残高で降順にソートして、上位10個（デフォルトのサイズ）のドキュメントを返します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match_all": {} },
  "sort": { "balance": { "order": "desc" } }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

[[gs-executing-searches]]
=== 検索の実行

基本的な検索パラメータをいくつか説明しました。Query DSLをもう少し詳しく調べましょう。最初に、返されたドキュメントフィールドを調べます。デフォルトでは、すべての検索結果の一部として、完全なJSONドキュメントが返されます。これは、ソースと呼ばれます（検索ヒットの`_source`フィールド）。ソースドキュメント全体が返されないようにしたい場合は、返されるソースの中から一部のフィールドだけを要求できます。

次の例は、検索から`account_number`と`balance`の2つのフィールド（`_source`ではなく）を返す方法を示しています。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match_all": {} },
  "_source": ["account_number", "balance"]
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記の例は、単に`_source`フィールドを減らします。`_source`という名前のフィールドを1つだけ返しますが、その中には`account_number`フィールドと`balance`フィールドだけが含まれます。

SQLの経験があれば、上記は`SQL SELECT FROM`フィールドリストの考え方に似ていると思うでしょう。

では、クエリ部分に移りましょう。前に、`match_all`クエリを使用してすべてのドキュメントに一致する方法を説明しました。ここでは、{ref}/query-dsl-match-query.html[`match`クエリ]という新しいクエリを紹介します。このクエリは、基本的なフィールド検索クエリと考えることができます（つまり、検索は特定のフィールドまたは一連のフィールドに対して行われます）。

次の例は、番号20が付いた口座を返します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match": { "account_number": 20 } }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

次の例は、アドレスに「mill」という語を含む口座をすべて返します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match": { "address": "mill" } }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

次の例は、アドレスに「mill」または「lane」という語を含む口座をすべて返します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match": { "address": "mill lane" } }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

次の例は、アドレスに「mill lane」という句を含む口座をすべて返す`match`の変形（`match_phrase`）です。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": { "match_phrase": { "address": "mill lane" } }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

次に、{ref}/query-dsl-bool-query.html[`bool` (Boolean)]について説明します。`bool`クエリを使用すると、ブール論理を使用して小さいクエリを組み合わせて大きいクエリにすることができます。

次の例は、2つの`match`クエリを構成して、アドレスに「mill」と「lane」を含む口座をすべて返します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "address": "mill" } },
        { "match": { "address": "lane" } }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記の例では、`bool must`句は、一致とみなされるドキュメントに対してtrueでなければならないすべてのクエリを指定します。

対照的に、次の例は、2つの`match`クエリを構成して、アドレスに「mill」または「lane」を含む口座をすべて返します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": {
    "bool": {
      "should": [
        { "match": { "address": "mill" } },
        { "match": { "address": "lane" } }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記の例では、`bool should`句は、一致とみなされるドキュメントに対していずれかがtrueでなければならないクエリのリストを指定します。

次の例は、2つの`match`クエリを構成して、アドレスに「mill」と「lane」のどちらも含まない口座をすべて返します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": {
    "bool": {
      "must_not": [
        { "match": { "address": "mill" } },
        { "match": { "address": "lane" } }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記の例では、`bool must_not`句は、一致とみなされるドキュメントに対してどちらもtrueであってはならないクエリのリストを指定します。

`must`句、`should`句、および`must_not`句を`bool`クエリ内に同時にまとめることができます。さらに、`bool`クエリをこれらの句の中に組み合わせて、複雑な多重レベルのブール論理を模倣できます。

次の例は、40歳ではあるがID（アイダホ）には住んでいない人の口座をすべて返します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": {
    "bool": {
      "must": [
        { "match": { "age": "40" } }
      ],
      "must_not": [
        { "match": { "state": "ID" } }
      ]
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

[[gs-executing-filters]]
=== フィルタの実行

前のセクションでは、ドキュメントスコア（検索結果内の`_score`フィールド）についての説明をスキップしました。スコアは、そのドキュメントが指定した検索クエリにどの程度一致しているかの相対的な基準となる数値です。スコアが高いほどドキュメントの関連性が高く、スコアが低いほどドキュメントの関連性が低くなります。

ただし、クエリが常にスコアを生成するとは限りません。特にクエリをドキュメントセットの「フィルタリング」にのみ使用した場合は、スコアを生成しません。Elasticsearchはこれらの状況を検知し、無駄なスコアを計算しないようにクエリの実行を自動で最適化します。

前のセクションで紹介した{ref}/query-dsl-bool-query.html[`bool`クエリ]は、`filter`句もサポートします。これにより、スコアの計算方法を変更せずに、クエリを使用して別の句が一致するドキュメントを限定することができます。一例として、{ref}/query-dsl-range-query.html[`range` クエリ]を紹介します。これを使用すると、値の範囲でドキュメントをフィルタできます。一般的に、数値または日付のフィルタリングに使用されます。

次の例は、boolクエリを使用して、残高が20000以上30000以下の口座をすべて返します。言い換えると、残高が20000以上で30000以下の口座を検索します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "query": {
    "bool": {
      "must": { "match_all": {} },
      "filter": {
        "range": {
          "balance": {
            "gte": 20000,
            "lte": 30000
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

上記を分析すると、boolクエリは`match_all`クエリ（query部）と`range`クエリ（filter部）を含んでいます。他のクエリをquery部とfilter部に置き換えることができます。上記の事例では、範囲内にあるドキュメントはすべて「同様に」一致する、つまり他に関連性が高いドキュメントがないため、rangeクエリは妥当です。

`match_all`、`match`、`bool`、および`range`クエリのほかに、利用可能なクエリタイプは数多くありますが、ここでは説明しません。これらのクエリの仕組みについて基本的に理解しましたので、この知識を他のクエリタイプの学習と実験に応用することは難しくありません。

[[gs-executing-aggregations]]
=== 集約の実行

アグリゲーションを使用すると、データの統計情報をグループ化したり展開したりすることができます。集約について考える上で最も簡単な方法は、集約とSQL GROUP BY機能およびSQL集約機能を同等とみなすことです。Elasticsearchでは、ヒットを返す検索を実行すると同時に、ヒットとは別の集約された結果を1つの応答にまとめて返すことができます。これは、クエリと複数の集約を実行し一回で両方（またはいずれか）の操作から結果を得ることができ、簡潔で単純化されたAPIを使用してネットワークの往復を回避するという点で、非常に強力で効率的です。

まず、次の例はすべての口座を州ごとにグループ化して、数を降順にソート（デフォルト）した上位10個（デフォルト）の州を返します。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "size": 0,
  "aggs": {
    "group_by_state": {
      "terms": {
        "field": "state.keyword"
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

SQLでは、上記の集約は次の考え方と類似しています。

[source,sh]
--------------------------------------------------
SELECT state, COUNT(*) FROM bank GROUP BY state ORDER BY COUNT(*) DESC
--------------------------------------------------

次のような応答が返ります（部分的に表示）。

[source,js]
--------------------------------------------------
{
  "took": 29,
  "timed_out": false,
  "_shards": {
    "total": 5,
    "successful": 5,
    "failed": 0
  },
  "hits" : {
    "total" : 1000,
    "max_score" : 0.0,
    "hits" : [ ]
  },
  "aggregations" : {
    "group_by_state" : {
      "doc_count_error_upper_bound": 20,
      "sum_other_doc_count": 770,
      "buckets" : [ {
        "key" : "ID",
        "doc_count" : 27
      }, {
        "key" : "TX",
        "doc_count" : 27
      }, {
        "key" : "AL",
        "doc_count" : 25
      }, {
        "key" : "MD",
        "doc_count" : 25
      }, {
        "key" : "TN",
        "doc_count" : 23
      }, {
        "key" : "MA",
        "doc_count" : 21
      }, {
        "key" : "NC",
        "doc_count" : 21
      }, {
        "key" : "ND",
        "doc_count" : 21
      }, {
        "key" : "ME",
        "doc_count" : 20
      }, {
        "key" : "MO",
        "doc_count" : 20
      } ]
    }
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took": 29/"took": $body.took/]

口座が`ID`（アイダホ）に27個、`TX`（テキサス）に27個、`AL`（アラバマ）に25個などとなっていることがわかります。

応答に集約結果だけを表示するようにするため、`size=0`を設定して検索ヒットを表示しないようにします。

前の集約を基にして、次の例は州ごとに平均の口座残高を計算します（数を降順にソートした上位10個の州）。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "size": 0,
  "aggs": {
    "group_by_state": {
      "terms": {
        "field": "state.keyword"
      },
      "aggs": {
        "average_balance": {
          "avg": {
            "field": "balance"
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

`average_balance`集約が`group_by_state`集約にどうネストされているかに注目してください。これは、すべての集約に共通のパターンです。集約内に集約を任意にネストして、ピボットされた必要な要約をデータから抽出できます。

では、前の集約を基にして、平均残高を降順にソートしてみましょう。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "size": 0,
  "aggs": {
    "group_by_state": {
      "terms": {
        "field": "state.keyword",
        "order": {
          "average_balance": "desc"
        }
      },
      "aggs": {
        "average_balance": {
          "avg": {
            "field": "balance"
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

次の例は、年齢層（20～29歳、30～39歳、および40～49歳）でグループ化してから性別でグループ化し、年齢層ごと、性別ごとの平均口座残高を得る方法を示しています。

[source,js]
--------------------------------------------------
GET /bank/_search
{
  "size": 0,
  "aggs": {
    "group_by_age": {
      "range": {
        "field": "age",
        "ranges": [
          {
            "from": 20,
            "to": 30
          },
          {
            "from": 30,
            "to": 40
          },
          {
            "from": 40,
            "to": 50
          }
        ]
      },
      "aggs": {
        "group_by_gender": {
          "terms": {
            "field": "gender.keyword"
          },
          "aggs": {
            "average_balance": {
              "avg": {
                "field": "balance"
              }
            }
          }
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

ここでは説明しませんが、ほかにも集約の機能はたくさんあります。さらに試してみたい場合は、まず{ref}/search-aggregations.html[集約リファレンスガイド]を読むことをお勧めします。

[[gs-conclusion]]
== まとめ

Elasticsearchはシンプルかつ複雑な製品です。これまで、Elasticsearchとは何か、その内部を調べる方法、およびREST APIを使用して操作する方法の基本について学習してきました。このチュートリアルが、Elasticsearchの理解に役立つだけでなく、さらにその他の優れた機能を活用する刺激になることを願います。
